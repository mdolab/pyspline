!    -*- f90 -*-
! Note: the context of this file is case sensitive.

python module pyspline_cs ! in 
    interface  ! in :pyspline
        subroutine b2ink(x,nx,y,ny,fcn,ldf,kx,ky,tx,ty,bcoef,work,iflag) ! in :pyspline:b2ink.f
            complex*16, intent(in), dimension(nx) :: x
            integer optional,check(len(x)>=nx),depend(x) :: nx=len(x)
            complex*16, intent(in),dimension(ny) :: y
            integer optional,check(len(y)>=ny),depend(y) :: ny=len(y)
            complex*16, intent(in), dimension(ldf,ny),depend(ny) :: fcn
            integer optional,check(shape(fcn,0)==ldf),depend(fcn) :: ldf=shape(fcn,0)
            integer, intent(in) :: kx
            integer, intent(in) :: ky
            complex*16, intent(out),dimension(nx+kx) :: tx
            complex*16, intent(out),dimension(ny+ky) :: ty
            complex*16, intent(out), dimension(nx,ny),depend(nx,ny) :: bcoef
            complex*16, optional, dimension(nx*ny + MAX(2*kx*(nx+1),2*ky*(ny+1))) ::work
            integer,optional,intent(in) :: iflag=0
        end subroutine b2ink

        function b2val(xval,yval,idx,idy,tx,ty,nx,ny,kx,ky,bcoef,work) ! in :pyspline:b2val.f
            complex*16,intent(in) :: xval
            complex*16,intent(in) :: yval
            integer,intent(in) :: idx
            integer,intent(in) :: idy
            complex*16,intent(in), dimension(nx+kx) :: tx
            complex*16,intent(in), dimension(ny+ky) :: ty
            integer optional,check(shape(bcoef,0)==nx),depend(bcoef) :: nx=shape(bcoef,0)
            integer optional,check(shape(bcoef,1)==ny),depend(bcoef) :: ny=shape(bcoef,1)
            integer,intent(in) :: kx
            integer,intent(in) :: ky
            complex*16,intent(in), dimension(nx,ny) :: bcoef
            complex*16,optional, dimension(3*MAX(kx,ky)+ky) :: work
            complex*16,intent(out) :: b2val
        end function b2val

        subroutine bintk(x,y,t,n,k,bcoef,q,work) ! in bintk.f
          complex*16,intent(in), dimension(n) :: x
          complex*16,intent(in), dimension(n),depend(n) :: y
          complex*16,intent(in), dimension(n+k) :: t
          integer optional,check(len(x)>=n),depend(x) :: n=len(x)
          integer,intent(in) :: k
          complex*16,intent(out), dimension(n),depend(n) :: bcoef
          complex*16,optional, dimension((2*k-1)*n) :: q
          complex*16,optional, dimension(2*k),depend(k) :: work
        end subroutine bintk

        function bvalu(t,a,n,k,ideriv,x,inbv,work) ! in bvalu.f
          complex*16,intent(in), dimension(n+k),depend(k) :: t
          complex*16,intent(in), dimension(n) :: a
          integer optional,check(len(a)>=n),depend(a) :: n=len(a)
          integer ,intent(in):: k
          integer ,intent(in):: ideriv
          complex*16 ,intent(in):: x
          integer,optional :: inbv
          complex*16,optional, dimension(3*k),depend(k) :: work
          complex*16, intent(out):: bvalu
        end function bvalu

        subroutine bknot(x,n,k,t) ! in bknot.f
          complex*16,intent(in), dimension(n) :: x
          integer optional,check(len(x)>=n),depend(x) :: n=len(x)
          integer,intent(in) :: k
          complex*16,intent(out), dimension(n+k),depend(n,k) :: t
        end subroutine bknot
        
        subroutine bvaluv(t,a,n,k,ideriv,x,y,nx,inbv,work) ! in bvaluV.f
          complex*16,intent(in), dimension(n+k),depend(n,k) :: t
          complex*16,intent(in), dimension(n) :: a
          integer optional,check(len(a)>=n),depend(a) :: n=len(a)
          integer, intent(in) :: k
          integer,intent(in) :: ideriv
          complex*16,intent(in), dimension(nx) :: x
          complex*16,intent(out), dimension(nx),depend(nx) :: y
          integer optional,check(len(x)>=nx),depend(x) :: nx=len(x)
          integer, optional :: inbv
          complex*16,optional, dimension(3 * k),depend(k) :: work
        end subroutine bvaluv

        subroutine b2valm(x,y,n,m,idx,idy,tx,ty,nx,ny,kx,ky,bcoef,z) ! in b2valM.f90
          complex*16,intent(in),dimension(n,m) :: x
          complex*16,intent(in),dimension(n,m),depend(n,m) :: y
          integer optional,check(shape(x,0)==n),depend(x) :: n=shape(x,0)
          integer optional,check(shape(x,1)==m),depend(x) :: m=shape(x,1)
          integer,intent(in) :: idx
          integer,intent(in) :: idy
          complex*16,intent(in), dimension(nx+kx),depend(nx,kx) :: tx
          complex*16,intent(in), dimension(ny+ky),depend(ny,ky) :: ty
          integer optional,check(shape(bcoef,0)==nx),depend(bcoef) :: nx=shape(bcoef,0)
          integer optional,check(shape(bcoef,1)==ny),depend(bcoef) :: ny=shape(bcoef,1)
          integer,intent(in) :: kx
          integer,intent(in) :: ky
          complex*16,intent(in), dimension(nx,ny) :: bcoef
          complex*16, intent(out), dimension(n,m),depend(n,m) :: z
        end subroutine b2valm

        subroutine b2valv(x,y,n,idx,idy,tx,ty,nx,ny,kx,ky,bcoef,z) ! in c_b2valV.f90
          use complexify
          complex*16,intent(in), dimension(n) :: x
          complex*16,intent(in), dimension(n),depend(n) :: y
          integer optional,check(len(x)>=n),depend(x) :: n=len(x)
          integer,intent(in) :: idx
          integer,intent(in) :: idy
          complex*16 dimension(nx+kx),depend(nx,kx) :: tx
          complex*16 dimension(ny+ky),depend(ny,ky) :: ty
          integer optional,check(shape(bcoef,0)==nx),depend(bcoef) :: nx=shape(bcoef,0)
          integer optional,check(shape(bcoef,1)==ny),depend(bcoef) :: ny=shape(bcoef,1)
          integer,intent(in) :: kx
          integer,intent(in) :: ky
          complex*16,intent(in), dimension(nx,ny) :: bcoef
          complex*16,intent(out), dimension(n),depend(n) :: z
        end subroutine b2valv

        subroutine updatesurfacepoints(coef,coef_update,update,tx,ty,kx,ky,nx,ny) ! in updateSurfacePoints.f90
            complex*16 dimension(nx,ny,3),intent(in) :: coef
            complex*16 dimension(nx,ny,3),intent(out),depend(nx,ny) :: coef_update
            complex*16 dimension(nx,ny),intent(in),depend(nx,ny) :: update
            complex*16 dimension(kx+nx),intent(in),depend(kx,nx) :: tx
            complex*16 dimension(kx+ny),intent(in),depend(kx,ny) :: ty
            integer intent(in) :: kx
            integer intent(in) :: ky
            integer optional,check(shape(coef,0)==nx),depend(coef) :: nx=shape(coef,0)
            integer optional,check(shape(coef,1)==ny),depend(coef) :: ny=shape(coef,1)
        end subroutine updatesurfacepoints
        

        subroutine getcoef(dir,s,t,x,rot,scale,s_pos,links,coef,nref,nx,ny) ! in :test:getcoef.f90
            integer intent(in) :: dir
            complex*16 dimension(nref),intent(in) :: s
            complex*16 dimension(nref + 2),intent(in),depend(nref) :: t
            complex*16 dimension(nref,3),intent(in),depend(nref) :: x
            complex*16 dimension(nref,3),intent(in),depend(nref) :: rot
            complex*16 dimension(nref),intent(in),depend(nref) :: scale
            complex*16 dimension(nx,ny),intent(in) :: s_pos
            complex*16 dimension(nx,ny,3),intent(in),depend(nx,ny) :: links
            complex*16 dimension(nx,ny,3),intent(out),depend(nx,ny) :: coef
            integer optional,check(len(s)>=nref),depend(s) :: nref=len(s)
            integer optional,check(shape(s_pos,0)==nx),depend(s_pos) :: nx=shape(s_pos,0)
            integer optional,check(shape(s_pos,1)==ny),depend(s_pos) :: ny=shape(s_pos,1)
        end subroutine getcoef

!         subroutine getcomplexcoef(dir,s,t,x,rot,scale,s_pos,links,coef,nref,ns,nx,ny) ! in :test:getComplexCoef.f90
!             integer intent(in) :: dir
!             complex*16 dimension(nref),intent(in) :: s
!             complex*16 dimension(nref + 2),intent(in),depend(nref) :: t
!             complex*16 dimension(nref,3),intent(in),depend(nref) :: x
!             complex*16 dimension(nref,3),intent(in),depend(nref) :: rot
!             complex*16 dimension(nref),intent(in),depend(nref) :: scale
!             complex*16 dimension(ns),intent(in) :: s_pos
!             complex*16 dimension(ns,3),intent(in),depend(ns) :: links
!             complex*16 dimension(nx,ny,3),intent(out),depend(nx,ny) :: coef
!             integer optional,check(len(s)>=nref),depend(s) :: nref=len(s)
!             integer optional,check(len(s_pos)>=ns),depend(s_pos) :: ns=len(s_pos)
!             integer :: nx
!             integer :: ny
!         end subroutine getcomplexcoef

    end interface 
end python module pyspline_cs

! This file was auto-generated with f2py (version:2_4422).
! See http://cens.ioc.ee/projects/f2py2e/
