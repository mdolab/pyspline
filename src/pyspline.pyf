!    -*- f90 -*-
! Note: the context of this file is case sensitive.

python module pyspline ! in 
    interface  ! in :pyspline
        subroutine b2ink(x,nx,y,ny,fcn,ldf,kx,ky,tx,ty,bcoef,work,iflag) ! in :pyspline:b2ink.f
            real*8, intent(in), dimension(nx) :: x
            integer optional,check(len(x)>=nx),depend(x) :: nx=len(x)
            real*8, intent(in),dimension(ny) :: y
            integer optional,check(len(y)>=ny),depend(y) :: ny=len(y)
            real*8, intent(in), dimension(ldf,ny),depend(ny) :: fcn
            integer optional,check(shape(fcn,0)==ldf),depend(fcn) :: ldf=shape(fcn,0)
            integer, intent(in) :: kx
            integer, intent(in) :: ky
            real*8, intent(out),dimension(nx+kx) :: tx
            real*8, intent(out),dimension(ny+ky) :: ty
            real*8, intent(out), dimension(nx,ny),depend(nx,ny) :: bcoef
            real*8, optional, dimension(nx*ny + MAX(2*kx*(nx+1),2*ky*(ny+1))) ::work
            integer,optional,intent(in) :: iflag=0
        end subroutine b2ink
        
!         subroutine b2ink_mod(x,nxdata,y,nydata,fcn,ldf,kx,ky,tx,ty,bcoef,work,iflag) ! in :pyspline:b2ink.f
!             real*8, intent(in), dimension(nxdata) :: x
!             integer optional,check(len(x)>=nxdata),depend(x) :: nxdata=len(x)
!             real*8, intent(in),dimension(nydata) :: y
!             integer optional,check(len(y)>=nydata),depend(y) :: nydata=len(y)
!             real*8, intent(in), dimension(ldf,nydata),depend(nydata) :: fcn
!             integer optional,check(shape(fcn,0)==ldf),depend(fcn) :: ldf=shape(fcn,0)
!             integer, intent(in) :: kx
!             integer, intent(in) :: ky
!             real*8, intent(out),dimension(nxdata+2+kx) :: tx
!             real*8, intent(out),dimension(nydata+2+ky) :: ty
!             real*8, intent(out), dimension(nxdata+2,nydata+2),depend(nxdata,nydata) :: bcoef
! !            real*8, optional, dimension((nxdata+2)*(nydata+2) + MAX(2*kx*(nxdata+2+1),2*ky*(nydata+2+1))) ::work
!             real*8, optional, dimension(100000) :: work
!             integer,optional,intent(in) :: iflag=0
!           end subroutine b2ink_mod
        
        function b2val(xval,yval,idx,idy,tx,ty,nx,ny,kx,ky,bcoef,work) ! in :pyspline:b2val.f
            real*8,intent(in) :: xval
            real*8,intent(in) :: yval
            integer,intent(in) :: idx
            integer,intent(in) :: idy
            real*8,intent(in), dimension(nx+kx) :: tx
            real*8,intent(in), dimension(ny+ky) :: ty
            integer optional,check(shape(bcoef,0)==nx),depend(bcoef) :: nx=shape(bcoef,0)
            integer optional,check(shape(bcoef,1)==ny),depend(bcoef) :: ny=shape(bcoef,1)
            integer,intent(in) :: kx
            integer,intent(in) :: ky
            real*8,intent(in), dimension(nx,ny) :: bcoef
            real*8,optional, dimension(3*MAX(kx,ky)+ky) :: work
            real*8,intent(out) :: b2val
        end function b2val

        subroutine bintk(x,y,t,n,k,bcoef,q,work) ! in bintk.f
          real*8,intent(in), dimension(n) :: x
          real*8,intent(in), dimension(n),depend(n) :: y
          real*8,intent(in), dimension(n+k) :: t
          integer optional,check(len(x)>=n),depend(x) :: n=len(x)
          integer,intent(in) :: k
          real*8,intent(out), dimension(n),depend(n) :: bcoef
          real*8,optional, dimension((2*k-1)*n) :: q
          real*8,optional, dimension(2*k),depend(k) :: work
        end subroutine bintk

        function bvalu(t,a,n,k,ideriv,x,inbv,work) ! in bvalu.f
          real*8,intent(in), dimension(n+k),depend(k) :: t
          real*8,intent(in), dimension(n) :: a
          integer optional,check(len(a)>=n),depend(a) :: n=len(a)
          integer ,intent(in):: k
          integer ,intent(in):: ideriv
          real*8 ,intent(in):: x
          integer,optional :: inbv
          real*8,optional, dimension(3*k),depend(k) :: work
          real*8, intent(out):: bvalu
        end function bvalu

        subroutine bint4(x,y,ndata,ibcl,ibcr,fbcl,fbcr,kntopt,t,bcoef,n,k,w) ! in bint4.f
          real*8,intent(in), dimension(ndata) :: x
          real*8,intent(in), dimension(ndata) :: y
          integer,optional,check(len(x)>=ndata),depend(x) :: ndata=len(x)
          integer,intent(in) :: ibcl
          integer,intent(in) :: ibcr
          real*8,intent(in) :: fbcl
          real*8,intent(in) :: fbcr
          integer,intent(in) :: kntopt
          real*8,intent(out), dimension(ndata+6) :: t
          real*8,intent(out), dimension(ndata+2) :: bcoef
          integer,intent(out) :: n
          integer,intent(out) :: k
          real*8,optional, dimension(5*(ndata+2)) :: w
        end subroutine bint4

        subroutine curfit(iopt,m,x,y,w,xb,xe,k,s,nest,n,t,c,fp,wrk,lwrk,iwrk,ier) ! in curfit.f
          integer,intent(in) :: iopt
          integer optional,check(len(x)>=m),depend(x) :: m=len(x)
          real*8,intent(in), dimension(m) :: x
          real*8,intent(in), dimension(m),depend(m) :: y
          real*8,intent(in), dimension(m),depend(m) :: w
          real*8,intent(in):: xb
          real*8,intent(in) :: xe
          integer,intent(in) :: k
          real*8,intent(in) :: s
          integer optional,depend(m),depend(k):: nest=m+k+1
          integer,intent(in,out) :: n
          real*8,intent(in,out),dimension(nest) :: t
          real*8,intent(out), dimension(nest),depend(nest) :: c
          real*8,intent(out) :: fp
          real*8,optional, dimension((m*(k+1)+nest*(7+3*k))),depend(m),depend(k),depend(nest) :: wrk
          integer, optional,check(len(wrk)>=lwrk),depend(wrk) :: lwrk=len(wrk)
          integer, optional,dimension(nest),depend(nest) :: iwrk
          integer,intent(out) :: ier
        end subroutine curfit

        subroutine splev(t,n,c,k,x,y,m,ier) ! in splev.f
          real*8,intent(in), dimension(n) :: t
          integer, optional,check(len(t)>=n),depend(t) :: n=len(t)
          real*8,intent(in), dimension(n),depend(n) :: c
          integer,intent(in) :: k
          real*8,intent(in), dimension(m) :: x
          real*8,intent(out), dimension(m),depend(m) :: y
          integer, optional,check(len(x)>=m),depend(x) :: m=len(x)
          integer,intent(out) :: ier
        end subroutine splev

        subroutine parsur(iopt,ipar,idim,mu,u,mv,v,f,s,nuest,nvest,nu,tu,nv,tv,c,fp,wrk,lwrk,iwrk,kwrk,ier) ! in parsur.f
          integer,intent(in) :: iopt
          integer,intent(in), dimension(2) :: ipar
          integer,intent(in) :: idim
          integer optional,check(len(u)>=mu),depend(u) :: mu=len(u)
          real*8,intent(in), dimension(mu) :: u
          integer optional,check(len(v)>=mv),depend(v) :: mv=len(v)
          real*8,intent(in), dimension(mv) :: v
          real*8,intent(in), dimension(mu*mv*idim),depend(idim,mu,mv) :: f
          real*8,intent(in) :: s
          integer optional,depend(mu) :: nuest = mu+6
          integer optional,depend(mv) :: nvest = mv+6
          integer, intent(in,out) :: nu
          real*8, intent(in,out), dimension(nuest) :: tu
          integer,intent(in,out) :: nv
          real*8, intent(in,out),dimension(nvest) :: tv
          real*8,intent(out), dimension((nuest-4)*(nvest-4)*idim),depend(idim,nuest,nvest) :: c
          real*8,intent(out) :: fp
          real*8,optional, dimension(4+nuest*(mv*idim+11+4*1)+nvest*(11+4*1)+4*(mu+mv)+MAX(nuest,mv)*idim),depend(nuest,idim,nvest,mu,mv) :: wrk
          integer optional,check(len(wrk)>=lwrk),depend(wrk) :: lwrk=len(wrk)
          integer optional,dimension(3+mu+mv+nuest+nvest),depend(mu,mv,nuest,nvest) :: iwrk
          integer optional,check(len(iwrk)>=kwrk),depend(iwrk) :: kwrk=len(iwrk)
          integer,intent(out) :: ier
        end subroutine parsur

        subroutine surev(idim,tu,nu,tv,nv,c,u,mu,v,mv,f,mf,wrk,lwrk,iwrk,kwrk,ier) ! in surev.f
          integer,intent(in) :: idim
          real*8,intent(in), dimension(nu) :: tu
          integer optional,check(len(tu)>=nu),depend(tu) :: nu=len(tu)
          real*8,intent(in), dimension(nv) :: tv
          integer optional,check(len(tv)>=nv),depend(tv) :: nv=len(tv)
          real*8,intent(in), dimension((nu-4)*(nv-4)*idim),depend(idim,nu,nv) :: c
          real*8,intent(in), dimension(mu) :: u
          integer optional,check(len(u)>=mu),depend(u) :: mu=len(u)
          real*8,intent(in), dimension(mv) :: v
          integer optional,check(len(v)>=mv),depend(v) :: mv=len(v)
          real*8,intent(out), dimension(mu*mv*idim),depend(mu,mv,idim) :: f
          integer optional,check(len(f)>=mf),depend(f) :: mf=len(f)
          real*8 optional,dimension(4*(mu+mv)),depend(mu,mv) :: wrk
          integer optional,check(len(wrk)>=lwrk),depend(wrk) :: lwrk=len(wrk)
          integer optional,dimension(mu+mv),depend(mu,mv) :: iwrk
          integer optional,check(len(iwrk)>=kwrk),depend(iwrk) :: kwrk=len(iwrk)
          integer,intent(out) :: ier
        end subroutine surev

        subroutine surfit(iopt,m,x,y,z,w,xb,xe,yb,ye,kx,ky,s,nxest,nyest,nmax,eps,nx,tx,ny,ty,c,fp,wrk1,lwrk1,wrk2,lwrk2,iwrk,kwrk,ier) ! in surfit.f
          integer,intent(in) :: iopt
          integer optional,check(len(x)>=m),depend(x) :: m=len(x)
          real*8,intent(in), dimension(m) :: x
          real*8,intent(in), dimension(m),depend(m) :: y
          real*8,intent(in), dimension(m),depend(m) :: z
          real*8,intent(in), dimension(m),depend(m) :: w
          real*8,intent(in) :: xb
          real*8,intent(in) :: xe
          real*8,intent(in) :: yb
          real*8,intent(in) :: ye
          integer,intent(in) :: kx
          integer,intent(in) :: ky
          real*8,intent(in) :: s
          integer,intent(in) :: nxest
          integer,intent(in) :: nyest
          integer optional,check(len(tx)>=nmax),depend(tx) :: nmax=len(tx)
          real*8,optional :: eps=1.0e-16
          integer,intent(in,out) :: nx
          real*8,intent(in,out), dimension(nmax) :: tx
          integer,intent(in,out) :: ny
          real*8,intent(in,out), dimension(nmax),depend(nmax) :: ty
          real*8,intent(out), dimension((nxest-kx-1)*(nyest-ky-1)),depend(kx,ky,nxest,nyest) :: c
          real*8,intent(out) :: fp
          !real*8,optional, dimension(nxest*nyest*(2+kx*nyest+2*ky*nxest)+2*(nxest+nyest + 6*(m+MAX(nxest,nyest))+MAX(nxest,nyest))),depend(nxest,nyest,kx,kv,m) :: wrk1
          real*8,optional,dimension(10e6) :: wrk1
          integer, optional,check(len(wrk1)>=lwrk1),depend(wrk1) :: lwrk1=len(wrk1)
          !real*8,optional, dimension(nxest*nyest*(kx*nyest+ky*nxest)+nxest+nyest),depend(kx,ky,nxest,nyest) :: wrk2
          real*8, optional,dimension(1e6) :: wrk2
          integer, optional,check(len(wrk2)>=lwrk2),depend(wrk2) :: lwrk2=len(wrk2)
          integer,optional, dimension(m+(nxest-2*kx-1)*(nyest-2*ky-1)):: iwrk
          integer optional,check(len(iwrk)>=kwrk),depend(iwrk) :: kwrk=len(iwrk)
          integer,intent(out) :: ier
        end subroutine surfit


        subroutine bispev(tx,nx,ty,ny,c,kx,ky,x,mx,y,my,z,wrk,lwrk,iwrk,kwrk,ier) ! in bispev.f
          real*8,intent(in), dimension(nx) :: tx
          integer optional,check(len(tx)>=nx),depend(tx) :: nx=len(tx)
          real*8,intent(in), dimension(ny) :: ty
          integer optional,check(len(ty)>=ny),depend(ty) :: ny=len(ty)
          real*8,intent(in), dimension((nx-kx-1)*(ny-ky-1)),depend(nx,ny,kx,ky) :: c
          integer,intent(in) :: kx
          integer,intent(in) :: ky
          real*8,intent(in), dimension(mx) :: x
          integer optional,check(len(x)>=mx),depend(x) :: mx=len(x)
          real*8,intent(in), dimension(my) :: y
          integer optional,check(len(y)>=my),depend(y) :: my=len(y)
          real*8,intent(out), dimension(mx*my),depend(mx,my) :: z
          real*8, optional,dimension(mx*(kx+1)+my*(ky+1)),depend(mx,my,kx,ky) :: wrk
          integer optional,check(len(wrk)>=lwrk),depend(wrk) :: lwrk=len(wrk)
          integer optional,dimension(mx+my),depend(mx,my) :: iwrk
          integer optional,check(len(iwrk)>=kwrk),depend(iwrk) :: kwrk=len(iwrk)
          integer,intent(out) :: ier
        end subroutine bispev

        subroutine bknot(x,n,k,t) ! in bknot.f
          real*8,intent(in), dimension(n) :: x
          integer optional,check(len(x)>=n),depend(x) :: n=len(x)
          integer,intent(in) :: k
          real*8,intent(out), dimension(n+k),depend(n,k) :: t
        end subroutine bknot

        subroutine bvaluv(t,a,n,k,ideriv,x,y,nx,inbv,work) ! in bvaluV.f
          real*8,intent(in), dimension(n+k),depend(n,k) :: t
          real*8,intent(in), dimension(n) :: a
          integer optional,check(len(a)>=n),depend(a) :: n=len(a)
          integer, intent(in) :: k
          integer,intent(in) :: ideriv
          real*8,intent(in), dimension(nx) :: x
          real*8,intent(out), dimension(nx),depend(nx) :: y
          integer optional,check(len(x)>=nx),depend(x) :: nx=len(x)
          integer, optional :: inbv
          real*8,optional, dimension(3 * k),depend(k) :: work
        end subroutine bvaluv

        subroutine fit_foil(m,n,a,x1,x2,y1,y2,coefs) ! in fit_foil.f90
          integer optional,check(shape(a,0)==m),depend(a) :: m=shape(a,0)
          integer optional,intent(in),check(shape(a,1)==n),depend(a) :: n=shape(a,1)
          double precision dimension(m,n),intent(in) :: a
          double precision dimension(m),intent(in,copy),depend(m) :: x1
          double precision dimension(m),intent(in,copy),depend(m) :: x2
          double precision dimension(m),intent(in,copy),depend(m) :: y1
          double precision dimension(m),intent(in,copy),depend(m) :: y2
          double precision dimension(n,4),intent(out),depend(n) :: coefs
        end subroutine fit_foil

        subroutine b2valm(x,y,n,m,idx,idy,tx,ty,nx,ny,kx,ky,bcoef,z) ! in b2valM.f90
          real*8,intent(in),dimension(n,m) :: x
          real*8,intent(in),dimension(n,m),depend(n,m) :: y
          integer optional,check(shape(x,0)==n),depend(x) :: n=shape(x,0)
          integer optional,check(shape(x,1)==m),depend(x) :: m=shape(x,1)
          integer,intent(in) :: idx
          integer,intent(in) :: idy
          real*8,intent(in), dimension(nx+ky),depend(nx,ky) :: tx
          real*8,intent(in), dimension(ny+ky),depend(ny,ky) :: ty
          integer optional,check(shape(bcoef,0)==nx),depend(bcoef) :: nx=shape(bcoef,0)
          integer optional,check(shape(bcoef,1)==ny),depend(bcoef) :: ny=shape(bcoef,1)
          integer,intent(in) :: kx
          integer,intent(in) :: ky
          real*8,intent(in), dimension(nx,ny) :: bcoef
          real*8,intent(out), dimension(n,m),depend(n,m) :: z
        end subroutine b2valm

        subroutine b2valv(x,y,n,idx,idy,tx,ty,nx,ny,kx,ky,bcoef,z) ! in c_b2valV.f90
          real*8,intent(in), dimension(n) :: x
          real*8,intent(in), dimension(n),depend(n) :: y
          integer optional,check(len(x)>=n),depend(x) :: n=len(x)
          integer,intent(in) :: idx
          integer,intent(in) :: idy
          real*8 dimension(nx+kx),depend(nx,kx) :: tx
          real*8 dimension(ny+ky),depend(ny,ky) :: ty
          integer optional,check(shape(bcoef,0)==nx),depend(bcoef) :: nx=shape(bcoef,0)
          integer optional,check(shape(bcoef,1)==ny),depend(bcoef) :: ny=shape(bcoef,1)
          integer,intent(in) :: kx
          integer,intent(in) :: ky
          real*8,intent(in), dimension(nx,ny) :: bcoef
          real*8,intent(out), dimension(n),depend(n) :: z
        end subroutine b2valv

        subroutine fit_surf(nsurf,nu,nv,nctlu,nctlv,ncon,a,x,b,d,ctl) ! in fit_surf.f90
          integer intent(in) :: nsurf
          integer intent(in) :: nu
          integer intent(in) :: nv
          integer intent(in) :: nctlu
          integer intent(in) :: nctlv
          integer intent(in) :: ncon
          double precision dimension(nsurf,nu*nv,nctlu*nctlv),intent(in),depend(nsurf,nu,nv,nctlu,nctlv) :: a
          double precision dimension(nsurf,nu,nv,3),intent(in),depend(nsurf,nu,nv) :: x
          double precision dimension(ncon,nsurf*3*nctlu*nctlv),intent(in),depend(nsurf,nctlu,nctlv,ncon) :: b
          double precision dimension(ncon),intent(in),depend(ncon) :: d
          double precision dimension(nsurf,nctlu,nctlv,3),intent(out),depend(nsurf,nctlu,nctlv) :: ctl
        end subroutine fit_surf

     end interface
end python module pyspline

! This file was auto-generated with f2py (version:2_4422).
! See http://cens.ioc.ee/projects/f2py2e/
