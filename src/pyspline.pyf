  !    -*- f90 -*-
  ! Note: the context of this file is case sensitive.
  
  python module pyspline ! in 
  interface  ! in :pyspline

     ! --------------------- Curve Functions ------------------
     subroutine compute_curve(s,x,t,k,n,nctl,ndim,coef,niter,tol,rms) ! in :test:compute_curve.f90
       use lms_jacobian
       use lsqrmodule,,only: lsqr
       use lsqrcheckmodule,,only: acheck,xcheck
       double precision dimension(n),intent(in,out) :: s
       double precision dimension(n,ndim),intent(in),depend(n) :: x
       double precision dimension(nctl+k),intent(in),depend(k,nctl) :: t
       integer intent(in) :: k
       integer optional,intent(in),check(len(s)>=n),depend(s) :: n=len(s)
       integer optional,intent(in),check(shape(coef,0)==nctl),depend(coef) :: nctl=shape(coef,0)
       integer optional,intent(in),check(shape(x,1)==ndim),depend(x) :: ndim=shape(x,1)
       double precision dimension(nctl,ndim),intent(in,out),depend(ndim) :: coef
       integer intent(in) :: niter
       double precision intent(in) :: tol
       double precision intent(out) :: rms
     end subroutine compute_curve
   
  subroutine eval_curve(s,t,k,coef,nctl,ndim,val) ! in :test:eval_curve.f90
       double precision intent(in) :: s
       double precision dimension(nctl+k),intent(in),depend(k,nctl) :: t
       integer intent(in) :: k
       double precision dimension(nctl,ndim),intent(in) :: coef
       integer optional,intent(in),check(shape(coef,0)==nctl),depend(coef) :: nctl=shape(coef,0)
       integer optional,intent(in),check((shape(coef,1))==ndim),depend(coef) :: ndim=(shape(coef,1))
       double precision dimension(ndim),intent(out),depend(ndim) :: val
     end subroutine eval_curve

     subroutine eval_curve_v(s,t,k,coef,nctl,ndim,n,val) ! in :test:eval_curve_V.f90
       double precision dimension(n),intent(in) :: s
       double precision dimension(nctl+k),intent(in),depend(k,nctl) :: t
       integer intent(in) :: k
       double precision dimension(nctl,ndim),intent(in) :: coef
       integer optional,intent(in),check(shape(coef,0)==nctl),depend(coef) :: nctl=shape(coef,0)
       integer optional,intent(in),check(shape(coef,1)==ndim),depend(coef) :: ndim=shape(coef,1)
       integer optional,intent(in),check(len(s)>=n),depend(s) :: n=len(s)
       double precision dimension(n,ndim),intent(out),depend(n,ndim) :: val
     end subroutine eval_curve_v

     subroutine eval_curve_deriv(s,t,k,coef,nctl,ndim,val) ! in :test:eval_curve_deriv.f90
       double precision intent(in) :: s
       double precision dimension(nctl+k),intent(in),depend(k,nctl) :: t
       integer intent(in) :: k
       double precision dimension(nctl,ndim),intent(in) :: coef
       integer optional,intent(in),check(shape(coef,0)==nctl),depend(coef) :: nctl=shape(coef,0)
       integer optional,intent(in),check((shape(coef,1))==ndim),depend(coef) :: ndim=(shape(coef,1))
       double precision dimension(ndim),intent(out),depend(ndim) :: val
     end subroutine eval_curve_deriv

     subroutine eval_curve_deriv_v(s,t,k,coef,nctl,ndim,n,val) ! in :test:eval_curve_V.f90
       double precision dimension(n),intent(in) :: s
       double precision dimension(nctl+k),intent(in),depend(k,nctl) :: t
       integer intent(in) :: k
       double precision dimension(nctl,ndim),intent(in) :: coef
       integer optional,intent(in),check(shape(coef,0)==nctl),depend(coef) :: nctl=shape(coef,0)
       integer optional,intent(in),check(shape(coef,1)==ndim),depend(coef) :: ndim=shape(coef,1)
       integer optional,intent(in),check(len(s)>=n),depend(s) :: n=len(s)
       double precision dimension(n,ndim),intent(out),depend(n,ndim) :: val
     end subroutine eval_curve_deriv_v

     subroutine eval_curve_deriv2(s,t,k,coef,nctl,ndim,val) ! in :test:eval_curve_deriv.f90
       double precision intent(in) :: s
       double precision dimension(nctl+k),intent(in),depend(k,nctl) :: t
       integer intent(in) :: k
       double precision dimension(nctl,ndim),intent(in) :: coef
       integer optional,intent(in),check(shape(coef,0)==nctl),depend(coef) :: nctl=shape(coef,0)
       integer optional,intent(in),check((shape(coef,1))==ndim),depend(coef) :: ndim=(shape(coef,1))
       double precision dimension(ndim),intent(out),depend(ndim) :: val
     end subroutine eval_curve_deriv2

     subroutine eval_curve_deriv2_v(s,t,k,coef,nctl,ndim,n,val) ! in :test:eval_curve_V.f90
       double precision dimension(n),intent(in) :: s
       double precision dimension(nctl+k),intent(in),depend(k,nctl) :: t
       integer intent(in) :: k
       double precision dimension(nctl,ndim),intent(in) :: coef
       integer optional,intent(in),check(shape(coef,0)==nctl),depend(coef) :: nctl=shape(coef,0)
       integer optional,intent(in),check(shape(coef,1)==ndim),depend(coef) :: ndim=shape(coef,1)
       integer optional,intent(in),check(len(s)>=n),depend(s) :: n=len(s)
       double precision dimension(n,ndim),intent(out),depend(n,ndim) :: val
     end subroutine eval_curve_deriv2_v

     ! --------------------- Surface Function -----------------

     subroutine compute_surface(x,u,v,tu,tv,ku,kv,nctlu,nctlv,nu,nv,ndim,coef,niter,tol,rms) ! in :test.pyf:compute_surface.f90
       use lms_jacobian
       use lsqrmodule,,only: lsqr
       use lsqrcheckmodule,,only: acheck,xcheck
       double precision dimension(nu,nv,ndim),intent(in) :: x
       double precision dimension(nu,nv),intent(in,out),depend(nu,nv) :: u
       double precision dimension(nu,nv),intent(in,out),depend(nu,nv) :: v
       double precision dimension(nctlu+ku),intent(in),depend(ku,nctlu) :: tu
       double precision dimension(nctlv+kv),intent(in),depend(kv,nctlv) :: tv
       integer intent(in) :: ku
       integer intent(in) :: kv
       integer optional,intent(in),check(shape(coef,0)==nctlu),depend(coef) :: nctlu=shape(coef,0)
       integer optional,intent(in),check(shape(coef,1)==nctlv),depend(coef) :: nctlv=shape(coef,1)
       integer optional,intent(in),check(shape(x,0)==nu),depend(x) :: nu=shape(x,0)
       integer optional,intent(in),check(shape(x,1)==nv),depend(x) :: nv=shape(x,1)
       integer optional,intent(in),check(shape(x,2)==ndim),depend(x) :: ndim=shape(x,2)
       double precision dimension(nctlu,nctlv,ndim),intent(in,out),depend(ndim) :: coef
       integer intent(in) :: niter
       double precision intent(in) :: tol
       double precision intent(out) :: rms
     end subroutine compute_surface

     subroutine eval_surface(u,v,tu,tv,ku,kv,coef,nctlu,nctlv,ndim,val) ! in :test:eval_surface.f90
       double precision intent(in) :: u
       double precision intent(in) :: v
       double precision dimension(nctlu+ku),intent(in),depend(ku,nctlu) :: tu
       double precision dimension(nctlv+kv),intent(in),depend(kv,nctlv) :: tv
       integer intent(in) :: ku
       integer intent(in) :: kv
       double precision dimension(nctlu,nctlv,ndim),intent(in) :: coef
       integer optional,intent(in),check(shape(coef,0)==nctlu),depend(coef) :: nctlu=shape(coef,0)
       integer optional,intent(in),check(shape(coef,1)==nctlv),depend(coef) :: nctlv=shape(coef,1)
       integer optional,intent(in),check(shape(coef,2)==ndim),depend(coef) :: ndim=shape(coef,2)
       double precision dimension(ndim),intent(out),depend(ndim) :: val
     end subroutine eval_surface

     subroutine eval_surface_v(u,v,tu,tv,ku,kv,coef,nctlu,nctlv,ndim,n,val) ! in :test:eval_surface.f90
       double precision dimension(n),intent(in) :: u
       double precision dimension(n),intent(in),depend(n) :: v
       double precision dimension(nctlu+ku),intent(in),depend(ku,nctlu) :: tu
       double precision dimension(nctlv+kv),intent(in),depend(kv,nctlv) :: tv
       integer intent(in) :: ku
       integer intent(in) :: kv
       double precision dimension(nctlu,nctlv,ndim),intent(in) :: coef
       integer optional,intent(in),check(shape(coef,0)==nctlu),depend(coef) :: nctlu=shape(coef,0)
       integer optional,intent(in),check(shape(coef,1)==nctlv),depend(coef) :: nctlv=shape(coef,1)
       integer optional,intent(in),check(shape(coef,2)==ndim),depend(coef) :: ndim=shape(coef,2)
       integer optional,intent(in),check(len(u)>=n),depend(u) :: n=len(u)
       double precision dimension(n,ndim),intent(out),depend(n,ndim) :: val
     end subroutine eval_surface_v

     subroutine eval_surface_m(u,v,tu,tv,ku,kv,coef,nctlu,nctlv,ndim,n,m,val) ! in :test:eval_surface.f90
       double precision dimension(n,m),intent(in) :: u
       double precision dimension(n,m),intent(in),depend(n,m) :: v
       double precision dimension(nctlu+ku),intent(in),depend(ku,nctlu) :: tu
       double precision dimension(nctlv+kv),intent(in),depend(kv,nctlv) :: tv
       integer intent(in) :: ku
       integer intent(in) :: kv
       double precision dimension(nctlu,nctlv,ndim),intent(in) :: coef
       integer optional,intent(in),check(shape(coef,0)==nctlu),depend(coef) :: nctlu=shape(coef,0)
       integer optional,intent(in),check(shape(coef,1)==nctlv),depend(coef) :: nctlv=shape(coef,1)
       integer optional,intent(in),check(shape(coef,2)==ndim),depend(coef) :: ndim=shape(coef,2)
       integer optional,intent(in),check(shape(u,0)==n),depend(u) :: n=shape(u,0)
       integer optional,intent(in),check(shape(u,1)==m),depend(u) :: m=shape(u,1)
       double precision dimension(n,m,ndim),intent(out),depend(n,m,ndim) :: val
     end subroutine eval_surface_m

     subroutine eval_surface_deriv(u,v,tu,tv,ku,kv,coef,nctlu,nctlv,ndim,val) ! in :test:eval_surface_deriv.f90
       double precision intent(in) :: u
       double precision intent(in) :: v
       double precision dimension(nctlu+ku),intent(in),depend(ku,nctlu) :: tu
       double precision dimension(nctlv+kv),intent(in),depend(kv,nctlv) :: tv
       integer intent(in) :: ku
       integer intent(in) :: kv
       double precision dimension(nctlu,nctlv,ndim),intent(in) :: coef
       integer optional,intent(in),check(shape(coef,0)==nctlu),depend(coef) :: nctlu=shape(coef,0)
       integer optional,intent(in),check(shape(coef,1)==nctlv),depend(coef) :: nctlv=shape(coef,1)
       integer optional,intent(in),check(shape(coef,2)==ndim),depend(coef) :: ndim=shape(coef,2)
       double precision dimension(2,ndim),intent(out),depend(ndim) :: val
     end subroutine eval_surface_deriv

     subroutine eval_surface_deriv_v(u,v,tu,tv,ku,kv,coef,nctlu,nctlv,ndim,n,val) ! in :test:eval_surface_deriv.f90
       double precision dimension(n),intent(in) :: u
       double precision dimension(n),intent(in),depend(n) :: v
       double precision dimension(nctlu+ku),intent(in),depend(ku,nctlu) :: tu
       double precision dimension(nctlv+kv),intent(in),depend(kv,nctlv) :: tv
       integer intent(in) :: ku
       integer intent(in) :: kv
       double precision dimension(nctlu,nctlv,ndim),intent(in) :: coef
       integer optional,intent(in),check(shape(coef,0)==nctlu),depend(coef) :: nctlu=shape(coef,0)
       integer optional,intent(in),check(shape(coef,1)==nctlv),depend(coef) :: nctlv=shape(coef,1)
       integer optional,intent(in),check(shape(coef,2)==ndim),depend(coef) :: ndim=shape(coef,2)
       integer optional,intent(in),check(len(u)>=n),depend(u) :: n=len(u)
       double precision dimension(n,2,ndim),intent(out),depend(n,ndim) :: val
     end subroutine eval_surface_deriv_v

     subroutine eval_surface_deriv_m(u,v,tu,tv,ku,kv,coef,nctlu,nctlv,ndim,n,m,val) ! in :test:eval_surface_deriv.f90
       double precision dimension(n,m),intent(in) :: u
       double precision dimension(n,m),intent(in),depend(n,m) :: v
       double precision dimension(nctlu+ku),intent(in),depend(ku,nctlu) :: tu
       double precision dimension(nctlv+kv),intent(in),depend(kv,nctlv) :: tv
       integer intent(in) :: ku
       integer intent(in) :: kv
       double precision dimension(nctlu,nctlv,ndim),intent(in) :: coef
       integer optional,intent(in),check(shape(coef,0)==nctlu),depend(coef) :: nctlu=shape(coef,0)
       integer optional,intent(in),check(shape(coef,1)==nctlv),depend(coef) :: nctlv=shape(coef,1)
       integer optional,intent(in),check(shape(coef,2)==ndim),depend(coef) :: ndim=shape(coef,2)
       integer optional,intent(in),check(shape(u,0)==n),depend(u) :: n=shape(u,0)
       integer optional,intent(in),check(shape(u,1)==m),depend(u) :: m=shape(u,1)
       double precision dimension(n,m,2,2,ndim),intent(out),depend(n,m,ndim) :: val
     end subroutine eval_surface_deriv_m

     subroutine eval_surface_deriv2(u,v,tu,tv,ku,kv,coef,nctlu,nctlv,ndim,val) ! in :test:eval_surface_deriv2.f90
       double precision intent(in) :: u
       double precision intent(in) :: v
       double precision dimension(nctlu+ku),intent(in),depend(ku,nctlu) :: tu
       double precision dimension(nctlv+kv),intent(in),depend(kv,nctlv) :: tv
       integer intent(in) :: ku
       integer intent(in) :: kv
       double precision dimension(nctlu,nctlv,ndim),intent(in) :: coef
       integer optional,intent(in),check(shape(coef,0)==nctlu),depend(coef) :: nctlu=shape(coef,0)
       integer optional,intent(in),check(shape(coef,1)==nctlv),depend(coef) :: nctlv=shape(coef,1)
       integer optional,intent(in),check(shape(coef,2)==ndim),depend(coef) :: ndim=shape(coef,2)
       double precision dimension(2,2,ndim),intent(out),depend(ndim) :: val
     end subroutine eval_surface_deriv2

     subroutine eval_surface_deriv2_v(u,v,tu,tv,ku,kv,coef,nctlu,nctlv,ndim,n,val) ! in :test:eval_surface_deriv2.f90
       double precision dimension(n),intent(in) :: u
       double precision dimension(n),intent(in),depend(n) :: v
       double precision dimension(nctlu+ku),intent(in),depend(ku,nctlu) :: tu
       double precision dimension(nctlv+kv),intent(in),depend(kv,nctlv) :: tv
       integer intent(in) :: ku
       integer intent(in) :: kv
       double precision dimension(nctlu,nctlv,ndim),intent(in) :: coef
       integer optional,intent(in),check(shape(coef,0)==nctlu),depend(coef) :: nctlu=shape(coef,0)
       integer optional,intent(in),check(shape(coef,1)==nctlv),depend(coef) :: nctlv=shape(coef,1)
       integer optional,intent(in),check(shape(coef,2)==ndim),depend(coef) :: ndim=shape(coef,2)
       integer optional,intent(in),check(len(u)>=n),depend(u) :: n=len(u)
       double precision dimension(n,2,2,ndim),intent(out),depend(n,ndim) :: val
     end subroutine eval_surface_deriv2_v

     subroutine eval_surface_deriv2_m(u,v,tu,tv,ku,kv,coef,nctlu,nctlv,ndim,n,m,val) ! in :test:eval_surface_deriv2.f90
       double precision dimension(n,m),intent(in) :: u
       double precision dimension(n,m),intent(in),depend(n,m) :: v
       double precision dimension(nctlu+ku),intent(in),depend(ku,nctlu) :: tu
       double precision dimension(nctlv+kv),intent(in),depend(kv,nctlv) :: tv
       integer intent(in) :: ku
       integer intent(in) :: kv
       double precision dimension(nctlu,nctlv,ndim),intent(in) :: coef
       integer optional,intent(in),check(shape(coef,0)==nctlu),depend(coef) :: nctlu=shape(coef,0)
       integer optional,intent(in),check(shape(coef,1)==nctlv),depend(coef) :: nctlv=shape(coef,1)
       integer optional,intent(in),check(shape(coef,2)==ndim),depend(coef) :: ndim=shape(coef,2)
       integer optional,intent(in),check(shape(u,0)==n),depend(u) :: n=shape(u,0)
       integer optional,intent(in),check(shape(u,1)==m),depend(u) :: m=shape(u,1)
       double precision dimension(n,m,2,2,ndim),intent(out),depend(n,m,ndim) :: val
     end subroutine eval_surface_deriv2_m

     ! ----------------  Projection Functions -----------------------
     subroutine point_curve(x0,t,k,coef,nctl,ndim,niter,eps1,eps2,s,diff) ! in :test:projections.f90
       double precision dimension(ndim),intent(in) :: x0
       double precision dimension(nctl+k),intent(in),depend(k,nctl) :: t
       integer intent(in) :: k
       double precision dimension(nctl,ndim),intent(in),depend(ndim) :: coef
       integer optional,intent(in),check(shape(coef,0)==nctl),depend(coef) :: nctl=shape(coef,0)
       integer optional,intent(in),check(len(x0)>=ndim),depend(x0) :: ndim=len(x0)
       double precision intent(in) :: niter
       double precision intent(in) :: eps1
       double precision intent(in) :: eps2
       double precision intent(in,out) :: s
       double precision dimension(ndim),intent(out),depend(ndim) :: diff
     end subroutine point_curve
     subroutine point_surface(x0,tu,tv,ku,kv,coef,nctlu,nctlv,ndim,niter,eps1,eps2,u,v,diff) ! in :test:projections.f90
       double precision dimension(ndim),intent(in) :: x0
       double precision dimension(nctlu+ku),intent(in),depend(ku,nctlu) :: tu
       double precision dimension(nctlv+kv),intent(in),depend(kv,nctlv) :: tv
       integer intent(in) :: ku
       integer intent(in) :: kv
       double precision dimension(nctlu,nctlv,ndim),intent(in),depend(ndim) :: coef
       integer optional,intent(in),check(shape(coef,0)==nctlu),depend(coef) :: nctlu=shape(coef,0)
       integer optional,intent(in),check(shape(coef,1)==nctlv),depend(coef) :: nctlv=shape(coef,1)
       integer optional,intent(in),check(len(x0)>=ndim),depend(x0) :: ndim=len(x0)
       integer intent(in) :: niter
       double precision intent(in) :: eps1
       double precision intent(in) :: eps2
       double precision intent(in,out) :: u
       double precision intent(in,out) :: v
       double precision dimension(ndim),intent(out),depend(ndim) :: diff
     end subroutine point_surface
     
     subroutine curve_curve(t1,k1,coef1,t2,k2,coef2,n1,n2,ndim,niter,eps1,eps2,s,t,diff) ! in :test:projections.f90
       double precision dimension(n1+k1),intent(in),depend(k1,n1) :: t1
       integer intent(in) :: k1
       double precision dimension(n1,ndim),intent(in) :: coef1
       double precision dimension(n2+k2),intent(in),depend(k2,n2) :: t2
       integer intent(in) :: k2
       double precision dimension(n2,ndim),intent(in),depend(ndim) :: coef2
       integer optional,intent(in),check(shape(coef1,0)==n1),depend(coef1) :: n1=shape(coef1,0)
       integer optional,intent(in),check(shape(coef2,0)==n2),depend(coef2) :: n2=shape(coef2,0)
       integer optional,intent(in),check(shape(coef1,1)==ndim),depend(coef1) :: ndim=shape(coef1,1)
       integer intent(in) :: niter
       double precision intent(in) :: eps1
       double precision intent(in) :: eps2
       double precision intent(in,out) :: s
       double precision intent(in,out) :: t
       double precision dimension(ndim),intent(out),depend(ndim) :: diff
     end subroutine curve_curve

     subroutine curve_surface(tc,kc,coefc,tu,tv,ku,kv,coefs,nctlc,nctlu,nctlv,ndim,niter,eps1,eps2,u,v,s,diff) ! in :test:projections.f90
       double precision dimension(nctlc+kc),intent(in),depend(kc,nctlc) :: tc
       integer intent(in) :: kc
       double precision dimension(nctlc,ndim),intent(in) :: coefc
       double precision dimension(nctlu+ku),intent(in),depend(ku,nctlu) :: tu
       double precision dimension(nctlv+kv),intent(in),depend(kv,nctlv) :: tv
       integer intent(in) :: ku
       integer intent(in) :: kv
       double precision dimension(nctlu,nctlv,ndim),intent(in),depend(ndim) :: coefs
       integer optional,intent(in),check(shape(coefc,0)==nctlc),depend(coefc) :: nctlc=shape(coefc,0)
       integer optional,intent(in),check(shape(coefs,0)==nctlu),depend(coefs) :: nctlu=shape(coefs,0)
       integer optional,intent(in),check(shape(coefs,1)==nctlv),depend(coefs) :: nctlv=shape(coefs,1)
       integer optional,intent(in),check(shape(coefc,1)==ndim),depend(coefc) :: ndim=shape(coefc,1)
       integer intent(in) :: niter
       double precision intent(in) :: eps1
       double precision intent(in) :: eps2
       double precision intent(in,out) :: u
       double precision intent(in,out) :: v
       double precision intent(in,out) :: s
       double precision dimension(ndim),intent(out),depend(ndim) :: diff
     end subroutine curve_surface

     ! ----------------- Misc Functions -----------------------------

     function poly_length(x,n,ndim) ! in :test:compute_curve.f90
       double precision dimension(n,ndim),intent(in) :: x
       integer optional,intent(in),check(shape(x,0)==n),depend(x) :: n=shape(x,0)
       integer optional,intent(in),check(shape(x,1)==ndim),depend(x) :: ndim=shape(x,1)
       double precision :: poly_length
     end function poly_length

     subroutine knots(x,n,nctl,k,t) ! in knots.f90
       double precision dimension(n),intent(in) :: x
       integer optional,intent(in),check(len(x)>=n),depend(x) :: n=len(x)
       integer intent(in) :: nctl
       integer intent(in) :: k
       double precision dimension(nctl+k),intent(out),depend(nctl,k) :: t
     end subroutine knots

     subroutine intrv(xt,lxt,x,ilo,ileft,mflag) ! in :test:intrv.f
       double precision dimension(lxt),intent(in) :: xt
       integer optional,check(len(xt)>=lxt),depend(xt) :: lxt=len(xt)
       double precision,intent(in)  :: x
       integer,intent(in) :: ilo
       integer,intent(out) :: ileft
       integer,intent(out) :: mflag
     end subroutine intrv

     subroutine surface_jacobian_wrap(u,v,tu,tv,ku,kv,nctlu,nctlv,nu,nv,jac) ! in :test:compute_surface.f90
       double precision dimension(nu,nv),intent(in) :: u
       double precision dimension(nu,nv),intent(in),depend(nu,nv) :: v
       double precision dimension(nctlu+ku),intent(in),depend(ku,nctlu) :: tu
       double precision dimension(nctlv+kv),intent(in),depend(kv,nctlv) :: tv
       integer intent(in) :: ku
       integer intent(in) :: kv
       integer intent(in) :: nctlu
       integer intent(in) :: nctlv
       integer optional,intent(in),check(shape(u,0)==nu),depend(u) :: nu=shape(u,0)
       integer optional,intent(in),check(shape(u,1)==nv),depend(u) :: nv=shape(u,1)
       double precision dimension(nu*nv,nctlu*nctlv),intent(out),depend(nu,nv,nctlu,nctlv) :: jac
     end subroutine surface_jacobian_wrap


  end interface
end program

  

!         subroutine getctlnormals(coef,l_index,g_index,normals,c_index,tx,ty,kx,ky,nx,ny,ncoef,n)
!             double precision dimension(ncoef,3),intent(in) :: coef
!             integer    dimension(n,2),intent(in)           :: l_index
!             integer    dimension(n), intent(in), depend(n) :: g_index
!             double precision dimension(n,3),intent(out),depend(n) :: normals
!             integer    dimension(nx,ny),intent(in) :: c_index
!             double precision dimension(kx+nx),intent(in),depend(kx,nx) :: tx
!             double precision dimension(ky+ny),intent(in),depend(ky,ny) :: ty
!             integer intent(in) :: kx
!             integer intent(in) :: ky
!             integer optional,check(shape(c_index,0)==nx),depend(c_index) :: nx=shape(c_index,0)
!             integer optional,check(shape(c_index,1)==ny),depend(c_index) :: ny=shape(c_index,1)
!             integer optional,check(shape(coef,0)==ncoef),depend(coef) :: ncoef = shape(coef,0)
!             integer optional,check(shape(l_index,0)==n),depend(l_index) :: n = shape(l_index,0)
!           end subroutine getctlnormals

!           subroutine curve_stiffness(t,n,k,alpha,beta,gpts,k0) ! in :test:curve_stiffness.f90
!             double precision dimension(n+k),intent(in),depend(n,k) :: t
!             integer optional,intent(in),check(len(gpts)>=n),depend(gpts) :: n=len(gpts)
!             integer intent(in) :: k
!             double precision intent(in) :: alpha
!             double precision intent(in) :: beta
!             double precision dimension(n),intent(in) :: gpts
!             double precision dimension(n,n),intent(out),depend(n,n) :: k0
!         end subroutine curve_stiffness
!         subroutine apply_constr(t,n,k,kstiff,constr,ndim,nconstr,knew,f) ! in :test:apply_constr.f90
!             double precision dimension(n+k),intent(in),depend(n,k) :: t
!             integer optional,intent(in),check(shape(kstiff,0)==n),depend(kstiff) :: n=shape(kstiff,0)
!             integer intent(in) :: k
!             double precision dimension(n,n),intent(in) :: kstiff
!             double precision dimension(nconstr,ndim + 2),intent(in) :: constr
!             integer optional,intent(in),check((shape(constr,1)-2)==ndim),depend(constr) :: ndim=(shape(constr,1)-2)
!             integer optional,intent(in),check(shape(constr,0)==nconstr),depend(constr) :: nconstr=shape(constr,0)
!             double precision dimension(n,n),intent(out),depend(n,n) :: knew
!             double precision dimension(n,ndim),intent(out),depend(n,ndim) :: f
!         end subroutine apply_constr

! This file was auto-generated with f2py (version:2_4422).
! See http://cens.ioc.ee/projects/f2py2e/


