  !    -*- f90 -*-
  ! Note: the context of this file is case sensitive.
  
  python module pyspline ! in 
  interface  ! in :pyspline

     ! --------------------- Curve Functions ------------------
 subroutine compute_curve(s,x,t,k,n,nctl,ndim,coef,niter,tol) ! in :test:compute_curve.f90
            double precision dimension(n),intent(inout) :: s
            double precision dimension(n,ndim),intent(in),depend(n) :: x
            double precision dimension(nctl+k),intent(inout),depend(k,nctl) :: t
            integer intent(in) :: k
            integer optional,intent(in),check(len(s)>=n),depend(s) :: n=len(s)
            integer intent(in) :: nctl
            integer optional,intent(in),check(shape(x,1)==ndim),depend(x) :: ndim=shape(x,1)
            double precision dimension(nctl,ndim),intent(out),depend(nctl,ndim) :: coef
            integer intent(in) :: niter
            double precision intent(in) :: tol
        end subroutine compute_curve

     subroutine eval_curve(s,t,k,coef,nctl,ndim,val) ! in :test:eval_curve.f90
       double precision intent(in) :: s
       double precision dimension(nctl+k),intent(in),depend(k,nctl) :: t
       integer intent(in) :: k
       double precision dimension(nctl,ndim),intent(in) :: coef
       integer optional,intent(in),check(shape(coef,0)==nctl),depend(coef) :: nctl=shape(coef,0)
       integer optional,intent(in),check((shape(coef,1))==ndim),depend(coef) :: ndim=(shape(coef,1))
       double precision dimension(ndim),intent(out),depend(ndim) :: val
     end subroutine eval_curve

     subroutine eval_curve_v(s,t,k,coef,nctl,ndim,n,val) ! in :test:eval_curve_V.f90
       double precision dimension(n),intent(in) :: s
       double precision dimension(nctl+k),intent(in),depend(k,nctl) :: t
       integer intent(in) :: k
       double precision dimension(nctl,ndim),intent(in) :: coef
       integer optional,intent(in),check(shape(coef,0)==nctl),depend(coef) :: nctl=shape(coef,0)
       integer optional,intent(in),check(shape(coef,1)==ndim),depend(coef) :: ndim=shape(coef,1)
       integer optional,intent(in),check(len(s)>=n),depend(s) :: n=len(s)
       double precision dimension(n,ndim),intent(out),depend(n,ndim) :: val
     end subroutine eval_curve_v

     subroutine eval_curve_deriv(s,t,k,coef,nctl,ndim,val) ! in :test:eval_curve_deriv.f90
       double precision intent(in) :: s
       double precision dimension(nctl+k),intent(in),depend(k,nctl) :: t
       integer intent(in) :: k
       double precision dimension(nctl,ndim),intent(in) :: coef
       integer optional,intent(in),check(shape(coef,0)==nctl),depend(coef) :: nctl=shape(coef,0)
       integer optional,intent(in),check((shape(coef,1))==ndim),depend(coef) :: ndim=(shape(coef,1))
       double precision dimension(ndim),intent(out),depend(ndim) :: val
     end subroutine eval_curve_deriv

     subroutine eval_curve_deriv_v(s,t,k,coef,nctl,ndim,n,val) ! in :test:eval_curve_V.f90
       double precision dimension(n),intent(in) :: s
       double precision dimension(nctl+k),intent(in),depend(k,nctl) :: t
       integer intent(in) :: k
       double precision dimension(nctl,ndim),intent(in) :: coef
       integer optional,intent(in),check(shape(coef,0)==nctl),depend(coef) :: nctl=shape(coef,0)
       integer optional,intent(in),check(shape(coef,1)==ndim),depend(coef) :: ndim=shape(coef,1)
       integer optional,intent(in),check(len(s)>=n),depend(s) :: n=len(s)
       double precision dimension(n,ndim),intent(out),depend(n,ndim) :: val
     end subroutine eval_curve_deriv_v

     subroutine eval_curve_deriv2(s,t,k,coef,nctl,ndim,val) ! in :test:eval_curve_deriv.f90
       double precision intent(in) :: s
       double precision dimension(nctl+k),intent(in),depend(k,nctl) :: t
       integer intent(in) :: k
       double precision dimension(nctl,ndim),intent(in) :: coef
       integer optional,intent(in),check(shape(coef,0)==nctl),depend(coef) :: nctl=shape(coef,0)
       integer optional,intent(in),check((shape(coef,1))==ndim),depend(coef) :: ndim=(shape(coef,1))
       double precision dimension(ndim),intent(out),depend(ndim) :: val
     end subroutine eval_curve_deriv2

     subroutine eval_curve_deriv2_v(s,t,k,coef,nctl,ndim,n,val) ! in :test:eval_curve_V.f90
       double precision dimension(n),intent(in) :: s
       double precision dimension(nctl+k),intent(in),depend(k,nctl) :: t
       integer intent(in) :: k
       double precision dimension(nctl,ndim),intent(in) :: coef
       integer optional,intent(in),check(shape(coef,0)==nctl),depend(coef) :: nctl=shape(coef,0)
       integer optional,intent(in),check(shape(coef,1)==ndim),depend(coef) :: ndim=shape(coef,1)
       integer optional,intent(in),check(len(s)>=n),depend(s) :: n=len(s)
       double precision dimension(n,ndim),intent(out),depend(n,ndim) :: val
     end subroutine eval_curve_deriv2_v

    !  subroutine curve_jacobian_linear(t,k,s,n,nctl,rows,cols,vals) ! in :test:compute_curve.f90
!        double precision dimension(nctl+k),intent(in),depend(k,nctl) :: t
!        integer intent(in) :: k
!        double precision dimension(n),intent(in) :: s
!        integer optional,intent(in),check(len(s)>=n),depend(s) :: n=len(s)
!        integer intent(in) :: nctl
!        integer dimension(n*k),intent(out),depend(k,n) :: rows
!        integer dimension(n*k),intent(out),depend(k,n) :: cols
!        double precision dimension(n*k),intent(out),depend(k,n) :: vals
!      end subroutine curve_jacobian_linear

     subroutine project_point_curve(x0,t,k,coef,nctl,ndim,niter,eps1,eps2,s) ! in :test:project_point_curve.f90
       double precision dimension(ndim),intent(in) :: x0
       double precision dimension(nctl+k),intent(in),depend(k,nctl) :: t
       integer intent(in) :: k
       double precision dimension(nctl,ndim),intent(in),depend(ndim) :: coef
       integer optional,intent(in),check(shape(coef,0)==nctl),depend(coef) :: nctl=shape(coef,0)
       integer optional,intent(in),check(len(x0)>=ndim),depend(x0) :: ndim=len(x0)
       double precision intent(in) :: niter
       double precision intent(in) :: eps1
       double precision intent(in) :: eps2
       double precision intent(out) :: s
       double precision dimension(ndim),intent(out), depend(ndim) :: diff
     end subroutine project_point_curve

    !  subroutine curve_para_corr(t,k,s,coef,nctl,ndim,length,n,x,rms) ! in :test:compute_curve.f90
!        double precision dimension(k+nctl),intent(in),depend(k,nctl) :: t
!        integer intent(in) :: k
!        double precision dimension(n),intent(in,out) :: s
!        double precision dimension(nctl,ndim),intent(in) :: coef
!        integer optional,intent(in),check(shape(coef,0)==nctl),depend(coef) :: nctl=shape(coef,0)
!        integer optional,intent(in),check(shape(coef,1)==ndim),depend(coef) :: ndim=shape(coef,1)
!        double precision intent(in) :: length
!        integer optional,intent(in),check(len(s)>=n),depend(s) :: n=len(s)
!        double precision dimension(n,ndim),intent(in),depend(n,ndim) :: x
!        double precision intent(out) :: rms
!      end subroutine curve_para_corr

     ! --------------------- Surface Function -----------------
     subroutine eval_surface(u,v,tu,tv,ku,kv,coef,nctlu,nctlv,ndim,val) ! in :test:eval_surface.f90
       double precision intent(in) :: u
       double precision intent(in) :: v
       double precision dimension(nctlu+ku),intent(in),depend(ku,nctlu) :: tu
       double precision dimension(nctlv+kv),intent(in),depend(kv,nctlv) :: tv
       integer intent(in) :: ku
       integer intent(in) :: kv
       double precision dimension(nctlu,nctlv,ndim),intent(in) :: coef
       integer optional,intent(in),check(shape(coef,0)==nctlu),depend(coef) :: nctlu=shape(coef,0)
       integer optional,intent(in),check(shape(coef,1)==nctlv),depend(coef) :: nctlv=shape(coef,1)
       integer optional,intent(in),check(shape(coef,2)==ndim),depend(coef) :: ndim=shape(coef,2)
       double precision dimension(ndim),intent(out),depend(ndim) :: val
     end subroutine eval_surface

     subroutine eval_surface_v(u,v,tu,tv,ku,kv,coef,nctlu,nctlv,ndim,n,val) ! in :test:eval_surface.f90
       double precision dimension(n),intent(in) :: u
       double precision dimension(n),intent(in),depend(n) :: v
       double precision dimension(nctlu+ku),intent(in),depend(ku,nctlu) :: tu
       double precision dimension(nctlv+kv),intent(in),depend(kv,nctlv) :: tv
       integer intent(in) :: ku
       integer intent(in) :: kv
       double precision dimension(nctlu,nctlv,ndim),intent(in) :: coef
       integer optional,intent(in),check(shape(coef,0)==nctlu),depend(coef) :: nctlu=shape(coef,0)
       integer optional,intent(in),check(shape(coef,1)==nctlv),depend(coef) :: nctlv=shape(coef,1)
       integer optional,intent(in),check(shape(coef,2)==ndim),depend(coef) :: ndim=shape(coef,2)
       integer optional,intent(in),check(len(u)>=n),depend(u) :: n=len(u)
       double precision dimension(n,ndim),intent(out),depend(n,ndim) :: val
     end subroutine eval_surface_v

     subroutine eval_surface_m(u,v,tu,tv,ku,kv,coef,nctlu,nctlv,ndim,n,m,val) ! in :test:eval_surface.f90
       double precision dimension(n,m),intent(in) :: u
       double precision dimension(n,m),intent(in),depend(n,m) :: v
       double precision dimension(nctlu+ku),intent(in),depend(ku,nctlu) :: tu
       double precision dimension(nctlv+kv),intent(in),depend(kv,nctlv) :: tv
       integer intent(in) :: ku
       integer intent(in) :: kv
       double precision dimension(nctlu,nctlv,ndim),intent(in) :: coef
       integer optional,intent(in),check(shape(coef,0)==nctlu),depend(coef) :: nctlu=shape(coef,0)
       integer optional,intent(in),check(shape(coef,1)==nctlv),depend(coef) :: nctlv=shape(coef,1)
       integer optional,intent(in),check(shape(coef,2)==ndim),depend(coef) :: ndim=shape(coef,2)
       integer optional,intent(in),check(shape(u,0)==n),depend(u) :: n=shape(u,0)
       integer optional,intent(in),check(shape(u,1)==m),depend(u) :: m=shape(u,1)
       double precision dimension(n,m,ndim),intent(out),depend(n,m,ndim) :: val
     end subroutine eval_surface_m

     subroutine eval_surface_deriv(u,v,tu,tv,ku,kv,coef,nctlu,nctlv,ndim,val) ! in :test:eval_surface_deriv.f90
       double precision intent(in) :: u
       double precision intent(in) :: v
       double precision dimension(nctlu+ku),intent(in),depend(ku,nctlu) :: tu
       double precision dimension(nctlv+kv),intent(in),depend(kv,nctlv) :: tv
       integer intent(in) :: ku
       integer intent(in) :: kv
       double precision dimension(nctlu,nctlv,ndim),intent(in) :: coef
       integer optional,intent(in),check(shape(coef,0)==nctlu),depend(coef) :: nctlu=shape(coef,0)
       integer optional,intent(in),check(shape(coef,1)==nctlv),depend(coef) :: nctlv=shape(coef,1)
       integer optional,intent(in),check(shape(coef,2)==ndim),depend(coef) :: ndim=shape(coef,2)
       double precision dimension(2,ndim),intent(out),depend(ndim) :: val
     end subroutine eval_surface_deriv

     subroutine eval_surface_deriv_v(u,v,tu,tv,ku,kv,coef,nctlu,nctlv,ndim,n,val) ! in :test:eval_surface_deriv.f90
       double precision dimension(n),intent(in) :: u
       double precision dimension(n),intent(in),depend(n) :: v
       double precision dimension(nctlu+ku),intent(in),depend(ku,nctlu) :: tu
       double precision dimension(nctlv+kv),intent(in),depend(kv,nctlv) :: tv
       integer intent(in) :: ku
       integer intent(in) :: kv
       double precision dimension(nctlu,nctlv,ndim),intent(in) :: coef
       integer optional,intent(in),check(shape(coef,0)==nctlu),depend(coef) :: nctlu=shape(coef,0)
       integer optional,intent(in),check(shape(coef,1)==nctlv),depend(coef) :: nctlv=shape(coef,1)
       integer optional,intent(in),check(shape(coef,2)==ndim),depend(coef) :: ndim=shape(coef,2)
       integer optional,intent(in),check(len(u)>=n),depend(u) :: n=len(u)
       double precision dimension(n,2,ndim),intent(out),depend(n,ndim) :: val
     end subroutine eval_surface_deriv_v

     subroutine eval_surface_deriv_m(u,v,tu,tv,ku,kv,coef,nctlu,nctlv,ndim,n,m,val) ! in :test:eval_surface_deriv.f90
       double precision dimension(n,m),intent(in) :: u
       double precision dimension(n,m),intent(in),depend(n,m) :: v
       double precision dimension(nctlu+ku),intent(in),depend(ku,nctlu) :: tu
       double precision dimension(nctlv+kv),intent(in),depend(kv,nctlv) :: tv
       integer intent(in) :: ku
       integer intent(in) :: kv
       double precision dimension(nctlu,nctlv,ndim),intent(in) :: coef
       integer optional,intent(in),check(shape(coef,0)==nctlu),depend(coef) :: nctlu=shape(coef,0)
       integer optional,intent(in),check(shape(coef,1)==nctlv),depend(coef) :: nctlv=shape(coef,1)
       integer optional,intent(in),check(shape(coef,2)==ndim),depend(coef) :: ndim=shape(coef,2)
       integer optional,intent(in),check(shape(u,0)==n),depend(u) :: n=shape(u,0)
       integer optional,intent(in),check(shape(u,1)==m),depend(u) :: m=shape(u,1)
       double precision dimension(n,m,2,2,ndim),intent(out),depend(n,m,ndim) :: val
     end subroutine eval_surface_deriv_m

     subroutine eval_surface_deriv2(u,v,tu,tv,ku,kv,coef,nctlu,nctlv,ndim,val) ! in :test:eval_surface_deriv2.f90
       double precision intent(in) :: u
       double precision intent(in) :: v
       double precision dimension(nctlu+ku),intent(in),depend(ku,nctlu) :: tu
       double precision dimension(nctlv+kv),intent(in),depend(kv,nctlv) :: tv
       integer intent(in) :: ku
       integer intent(in) :: kv
       double precision dimension(nctlu,nctlv,ndim),intent(in) :: coef
       integer optional,intent(in),check(shape(coef,0)==nctlu),depend(coef) :: nctlu=shape(coef,0)
       integer optional,intent(in),check(shape(coef,1)==nctlv),depend(coef) :: nctlv=shape(coef,1)
       integer optional,intent(in),check(shape(coef,2)==ndim),depend(coef) :: ndim=shape(coef,2)
       double precision dimension(2,2,ndim),intent(out),depend(ndim) :: val
     end subroutine eval_surface_deriv2

     subroutine eval_surface_deriv2_v(u,v,tu,tv,ku,kv,coef,nctlu,nctlv,ndim,n,val) ! in :test:eval_surface_deriv2.f90
       double precision dimension(n),intent(in) :: u
       double precision dimension(n),intent(in),depend(n) :: v
       double precision dimension(nctlu+ku),intent(in),depend(ku,nctlu) :: tu
       double precision dimension(nctlv+kv),intent(in),depend(kv,nctlv) :: tv
       integer intent(in) :: ku
       integer intent(in) :: kv
       double precision dimension(nctlu,nctlv,ndim),intent(in) :: coef
       integer optional,intent(in),check(shape(coef,0)==nctlu),depend(coef) :: nctlu=shape(coef,0)
       integer optional,intent(in),check(shape(coef,1)==nctlv),depend(coef) :: nctlv=shape(coef,1)
       integer optional,intent(in),check(shape(coef,2)==ndim),depend(coef) :: ndim=shape(coef,2)
       integer optional,intent(in),check(len(u)>=n),depend(u) :: n=len(u)
       double precision dimension(n,2,2,ndim),intent(out),depend(n,ndim) :: val
     end subroutine eval_surface_deriv2_v

     subroutine eval_surface_deriv2_m(u,v,tu,tv,ku,kv,coef,nctlu,nctlv,ndim,n,m,val) ! in :test:eval_surface_deriv2.f90
       double precision dimension(n,m),intent(in) :: u
       double precision dimension(n,m),intent(in),depend(n,m) :: v
       double precision dimension(nctlu+ku),intent(in),depend(ku,nctlu) :: tu
       double precision dimension(nctlv+kv),intent(in),depend(kv,nctlv) :: tv
       integer intent(in) :: ku
       integer intent(in) :: kv
       double precision dimension(nctlu,nctlv,ndim),intent(in) :: coef
       integer optional,intent(in),check(shape(coef,0)==nctlu),depend(coef) :: nctlu=shape(coef,0)
       integer optional,intent(in),check(shape(coef,1)==nctlv),depend(coef) :: nctlv=shape(coef,1)
       integer optional,intent(in),check(shape(coef,2)==ndim),depend(coef) :: ndim=shape(coef,2)
       integer optional,intent(in),check(shape(u,0)==n),depend(u) :: n=shape(u,0)
       integer optional,intent(in),check(shape(u,1)==m),depend(u) :: m=shape(u,1)
       double precision dimension(n,m,2,2,ndim),intent(out),depend(n,m,ndim) :: val
     end subroutine eval_surface_deriv2_m

     subroutine surface_jacobian_linear(u,v,tu,tv,ku,kv,nctlu,nctlv,nu,nv,rows,cols,vals) ! in :test:compute_surface.f90
       double precision dimension(nu,nv),intent(in) :: u
       double precision dimension(nu,nv),intent(in),depend(nu,nv) :: v
       double precision dimension(nctlu+ku),intent(in),depend(ku,nctlu) :: tu
       double precision dimension(nctlv+kv),intent(in),depend(kv,nctlv) :: tv
       integer intent(in) :: ku
       integer intent(in) :: kv
       integer intent(in) :: nctlu
       integer intent(in) :: nctlv
       integer optional,intent(in),check(shape(u,0)==nu),depend(u) :: nu=shape(u,0)
       integer optional,intent(in),check(shape(u,1)==nv),depend(u) :: nv=shape(u,1)
       integer dimension(nu*nv*ku*kv),intent(out),depend(ku,kv,nu,nv) :: rows
       integer dimension(nu*nv*ku*kv),intent(out),depend(ku,kv,nu,nv) :: cols
       double precision dimension(nu*nv*ku*kv),intent(out),depend(ku,kv,nu,nv) :: vals
     end subroutine surface_jacobian_linear

     subroutine surface_para_corr(tu,tv,ku,kv,u,v,coef,nctlu,nctlv,ndim,nu,nv,x,rms) ! in :test:compute_surface.f90
       double precision dimension(ku+nctlu),intent(in),depend(ku,nctlu) :: tu
       double precision dimension(kv+nctlv),intent(in),depend(kv,nctlv) :: tv
       integer intent(in) :: ku
       integer intent(in) :: kv
       double precision dimension(nu,nv),intent(in,out) :: u
       double precision dimension(nu,nv),intent(in,out),depend(nu,nv) :: v
       double precision dimension(nctlu,nctlv,ndim),intent(in) :: coef
       integer optional,intent(in),check(shape(coef,0)==nctlu),depend(coef) :: nctlu=shape(coef,0)
       integer optional,intent(in),check(shape(coef,1)==nctlv),depend(coef) :: nctlv=shape(coef,1)
       integer optional,intent(in),check(shape(coef,2)==ndim),depend(coef) :: ndim=shape(coef,2)
       integer optional,intent(in),check(shape(u,0)==nu),depend(u) :: nu=shape(u,0)
       integer optional,intent(in),check(shape(u,1)==nv),depend(u) :: nv=shape(u,1)
       double precision dimension(nu,nv,ndim),intent(in),depend(nu,nv,ndim) :: x
       double precision intent(out) :: rms
     end subroutine surface_para_corr

     subroutine project_point_surface(x0,tu,tv,ku,kv,coef,nctlu,nctlv,ndim,niter,eps1,eps2,u,v,diff) ! in :test:project_point_surface.f90
       double precision dimension(ndim),intent(in) :: x0
       double precision dimension(nctlu+ku),intent(in),depend(ku,nctlu) :: tu
       double precision dimension(nctlv+kv),intent(in),depend(kv,nctlv) :: tv
       integer intent(in) :: ku
       integer intent(in) :: kv
       double precision dimension(nctlu,nctlv,ndim),intent(in),depend(ndim) :: coef
       integer optional,intent(in),check(shape(coef,0)==nctlu),depend(coef) :: nctlu=shape(coef,0)
       integer optional,intent(in),check(shape(coef,1)==nctlv),depend(coef) :: nctlv=shape(coef,1)
       integer optional,intent(in),check(len(x0)>=ndim),depend(x0) :: ndim=len(x0)
       integer intent(in) :: niter
       double precision intent(in) :: eps1
       double precision intent(in) :: eps2
       double precision intent(out) :: u
       double precision intent(out) :: v
       double precision dimension(ndim),intent(out),depend(ndim) :: diff
     end subroutine project_point_surface

     ! ----------------- Misc Functions -----------------------------

     function poly_length(x,n,ndim) ! in :test:compute_curve.f90
       double precision dimension(n,ndim),intent(in) :: x
       integer optional,intent(in),check(shape(x,0)==n),depend(x) :: n=shape(x,0)
       integer optional,intent(in),check(shape(x,1)==ndim),depend(x) :: ndim=shape(x,1)
       double precision :: poly_length
     end function poly_length

     subroutine knots(x,n,nctl,k,t) ! in knots.f90
       double precision dimension(n),intent(in) :: x
       integer optional,intent(in),check(len(x)>=n),depend(x) :: n=len(x)
       integer intent(in) :: nctl
       integer intent(in) :: k
       double precision dimension(nctl+k),intent(out),depend(nctl,k) :: t
     end subroutine knots

     subroutine intrv(xt,lxt,x,ilo,ileft,mflag) ! in :test:intrv.f
       double precision dimension(lxt),intent(in) :: xt
       integer optional,check(len(xt)>=lxt),depend(xt) :: lxt=len(xt)
       double precision,intent(in)  :: x
       integer,intent(in) :: ilo
       integer,intent(out) :: ileft
       integer,intent(out) :: mflag
     end subroutine intrv
  end interface
end program


!   subroutine projectpoint(coef,kx,ky,nx,ny,tx,ty,x0,u0,v0,niter,tol,d,converged) ! in :test:projectpoint.f90
!             double precision dimension(nx,ny,3),intent(in) :: coef
!             integer intent(in) :: kx
!             integer intent(in) :: ky
!             integer optional,intent(in),check(shape(coef,0)==nx),depend(coef) :: nx=shape(coef,0)
!             integer optional,intent(in),check(shape(coef,1)==ny),depend(coef) :: ny=shape(coef,1)
!             double precision dimension(kx+nx),intent(in),depend(kx,nx) :: tx
!             double precision dimension(kx+ny),intent(in),depend(kx,ny) :: ty
!             double precision dimension(3),intent(in) :: x0
!             double precision intent(in,out) :: u0
!             double precision intent(in,out) :: v0
!             integer intent(in) :: niter
!             double precision intent(in) :: tol
!             double precision dimension(3),intent(out) :: d
!             integer intent(out) :: converged
!         end subroutine projectpoint    

!         subroutine getctlnormals(coef,l_index,g_index,normals,c_index,tx,ty,kx,ky,nx,ny,ncoef,n)
!             double precision dimension(ncoef,3),intent(in) :: coef
!             integer    dimension(n,2),intent(in)           :: l_index
!             integer    dimension(n), intent(in), depend(n) :: g_index
!             double precision dimension(n,3),intent(out),depend(n) :: normals
!             integer    dimension(nx,ny),intent(in) :: c_index
!             double precision dimension(kx+nx),intent(in),depend(kx,nx) :: tx
!             double precision dimension(ky+ny),intent(in),depend(ky,ny) :: ty
!             integer intent(in) :: kx
!             integer intent(in) :: ky
!             integer optional,check(shape(c_index,0)==nx),depend(c_index) :: nx=shape(c_index,0)
!             integer optional,check(shape(c_index,1)==ny),depend(c_index) :: ny=shape(c_index,1)
!             integer optional,check(shape(coef,0)==ncoef),depend(coef) :: ncoef = shape(coef,0)
!             integer optional,check(shape(l_index,0)==n),depend(l_index) :: n = shape(l_index,0)
!           end subroutine getctlnormals

!          subroutine mincurvedistance(t1,k1,coef1,t2,k2,coef2,n1,n2,s,t,niter,tol,d,converged) ! in :test:mincurvedistance.f90
!             double precision dimension(n1+k1),intent(in),depend(k1,n1) :: t1
!             integer intent(in) :: k1
!             double precision dimension(n1,3),intent(in) :: coef1
!             double precision dimension(n2+k2),intent(in),depend(k2,n2) :: t2
!             integer intent(in) :: k2
!             double precision dimension(n2,3),intent(in) :: coef2
!             integer optional,intent(in),check(len(coef1)>=n1),depend(coef1) :: n1=len(coef1)
!             integer optional,intent(in),check(len(coef2)>=n2),depend(coef2) :: n2=len(coef2)
!             double precision intent(in,out) :: s
!             double precision intent(in,out) :: t
!             integer intent(in) :: niter
!             double precision intent(in) :: tol
!             double precision intent(out) :: d
!             integer intent(out) :: converged
!           end subroutine mincurvedistance
!           subroutine curve_stiffness(t,n,k,alpha,beta,gpts,k0) ! in :test:curve_stiffness.f90
!             double precision dimension(n+k),intent(in),depend(n,k) :: t
!             integer optional,intent(in),check(len(gpts)>=n),depend(gpts) :: n=len(gpts)
!             integer intent(in) :: k
!             double precision intent(in) :: alpha
!             double precision intent(in) :: beta
!             double precision dimension(n),intent(in) :: gpts
!             double precision dimension(n,n),intent(out),depend(n,n) :: k0
!         end subroutine curve_stiffness
!         subroutine apply_constr(t,n,k,kstiff,constr,ndim,nconstr,knew,f) ! in :test:apply_constr.f90
!             double precision dimension(n+k),intent(in),depend(n,k) :: t
!             integer optional,intent(in),check(shape(kstiff,0)==n),depend(kstiff) :: n=shape(kstiff,0)
!             integer intent(in) :: k
!             double precision dimension(n,n),intent(in) :: kstiff
!             double precision dimension(nconstr,ndim + 2),intent(in) :: constr
!             integer optional,intent(in),check((shape(constr,1)-2)==ndim),depend(constr) :: ndim=(shape(constr,1)-2)
!             integer optional,intent(in),check(shape(constr,0)==nconstr),depend(constr) :: nconstr=shape(constr,0)
!             double precision dimension(n,n),intent(out),depend(n,n) :: knew
!             double precision dimension(n,ndim),intent(out),depend(n,ndim) :: f
!         end subroutine apply_constr

! This file was auto-generated with f2py (version:2_4422).
! See http://cens.ioc.ee/projects/f2py2e/



!----------------------------------------------
! Wrappers for fitpack functions no longer used
! ---------------------------------------------


!         subroutine curfit(iopt,m,x,y,w,xb,xe,k,s,nest,n,t,c,fp,wrk,lwrk,iwrk,ier) ! in curfit.f
!           integer,intent(in) :: iopt
!           integer optional,check(len(x)>=m),depend(x) :: m=len(x)
!           real*8,intent(in), dimension(m) :: x
!           real*8,intent(in), dimension(m),depend(m) :: y
!           real*8,intent(in), dimension(m),depend(m) :: w
!           real*8,intent(in):: xb
!           real*8,intent(in) :: xe
!           integer,intent(in) :: k
!           real*8,intent(in) :: s
!           integer optional,depend(m),depend(k):: nest=m+k+1
!           integer,intent(in,out) :: n
!           real*8,intent(in,out),dimension(nest) :: t
!           real*8,intent(out), dimension(nest),depend(nest) :: c
!           real*8,intent(out) :: fp
!           real*8,optional, dimension((m*(k+1)+nest*(7+3*k))),depend(m),depend(k),depend(nest) :: wrk
!           integer, optional,check(len(wrk)>=lwrk),depend(wrk) :: lwrk=len(wrk)
!           integer, optional,dimension(nest),depend(nest) :: iwrk
!           integer,intent(out) :: ier
!         end subroutine curfit

!         subroutine splev(t,n,c,k,x,y,m,ier) ! in splev.f
!           real*8,intent(in), dimension(n) :: t
!           integer, optional,check(len(t)>=n),depend(t) :: n=len(t)
!           real*8,intent(in), dimension(n),depend(n) :: c
!           integer,intent(in) :: k
!           real*8,intent(in), dimension(m) :: x
!           real*8,intent(out), dimension(m),depend(m) :: y
!           integer, optional,check(len(x)>=m),depend(x) :: m=len(x)
!           integer,intent(out) :: ier
!         end subroutine splev

!         subroutine parsur(iopt,ipar,idim,mu,u,mv,v,f,s,nuest,nvest,nu,tu,nv,tv,c,fp,wrk,lwrk,iwrk,kwrk,ier) ! in parsur.f
!           integer,intent(in) :: iopt
!           integer,intent(in), dimension(2) :: ipar
!           integer,intent(in) :: idim
!           integer optional,check(len(u)>=mu),depend(u) :: mu=len(u)
!           real*8,intent(in), dimension(mu) :: u
!           integer optional,check(len(v)>=mv),depend(v) :: mv=len(v)
!           real*8,intent(in), dimension(mv) :: v
!           real*8,intent(in), dimension(mu*mv*idim),depend(idim,mu,mv) :: f
!           real*8,intent(in) :: s
!           integer optional,depend(mu) :: nuest = mu+6
!           integer optional,depend(mv) :: nvest = mv+6
!           integer, intent(in,out) :: nu
!           real*8, intent(in,out), dimension(nuest) :: tu
!           integer,intent(in,out) :: nv
!           real*8, intent(in,out),dimension(nvest) :: tv
!           real*8,intent(out), dimension((nuest-4)*(nvest-4)*idim),depend(idim,nuest,nvest) :: c
!           real*8,intent(out) :: fp
!           real*8,optional, dimension(4+nuest*(mv*idim+11+4*1)+nvest*(11+4*1)+4*(mu+mv)+MAX(nuest,mv)*idim),depend(nuest,idim,nvest,mu,mv) :: wrk
!           integer optional,check(len(wrk)>=lwrk),depend(wrk) :: lwrk=len(wrk)
!           integer optional,dimension(3+mu+mv+nuest+nvest),depend(mu,mv,nuest,nvest) :: iwrk
!           integer optional,check(len(iwrk)>=kwrk),depend(iwrk) :: kwrk=len(iwrk)
!           integer,intent(out) :: ier
!         end subroutine parsur

!         subroutine surev(idim,tu,nu,tv,nv,c,u,mu,v,mv,f,mf,wrk,lwrk,iwrk,kwrk,ier) ! in surev.f
!           integer,intent(in) :: idim
!           real*8,intent(in), dimension(nu) :: tu
!           integer optional,check(len(tu)>=nu),depend(tu) :: nu=len(tu)
!           real*8,intent(in), dimension(nv) :: tv
!           integer optional,check(len(tv)>=nv),depend(tv) :: nv=len(tv)
!           real*8,intent(in), dimension((nu-4)*(nv-4)*idim),depend(idim,nu,nv) :: c
!           real*8,intent(in), dimension(mu) :: u
!           integer optional,check(len(u)>=mu),depend(u) :: mu=len(u)
!           real*8,intent(in), dimension(mv) :: v
!           integer optional,check(len(v)>=mv),depend(v) :: mv=len(v)
!           real*8,intent(out), dimension(mu*mv*idim),depend(mu,mv,idim) :: f
!           integer optional,check(len(f)>=mf),depend(f) :: mf=len(f)
!           real*8 optional,dimension(4*(mu+mv)),depend(mu,mv) :: wrk
!           integer optional,check(len(wrk)>=lwrk),depend(wrk) :: lwrk=len(wrk)
!           integer optional,dimension(mu+mv),depend(mu,mv) :: iwrk
!           integer optional,check(len(iwrk)>=kwrk),depend(iwrk) :: kwrk=len(iwrk)
!           integer,intent(out) :: ier
!         end subroutine surev

!         subroutine surfit(iopt,m,x,y,z,w,xb,xe,yb,ye,kx,ky,s,nxest,nyest,nmax,eps,nx,tx,ny,ty,c,fp,wrk1,lwrk1,wrk2,lwrk2,iwrk,kwrk,ier) ! in surfit.f
!           integer,intent(in) :: iopt
!           integer optional,check(len(x)>=m),depend(x) :: m=len(x)
!           real*8,intent(in), dimension(m) :: x
!           real*8,intent(in), dimension(m),depend(m) :: y
!           real*8,intent(in), dimension(m),depend(m) :: z
!           real*8,intent(in), dimension(m),depend(m) :: w
!           real*8,intent(in) :: xb
!           real*8,intent(in) :: xe
!           real*8,intent(in) :: yb
!           real*8,intent(in) :: ye
!           integer,intent(in) :: kx
!           integer,intent(in) :: ky
!           real*8,intent(in) :: s
!           integer,intent(in) :: nxest
!           integer,intent(in) :: nyest
!           integer optional,check(len(tx)>=nmax),depend(tx) :: nmax=len(tx)
!           real*8,optional :: eps=1.0e-16
!           integer,intent(in,out) :: nx
!           real*8,intent(in,out), dimension(nmax) :: tx
!           integer,intent(in,out) :: ny
!           real*8,intent(in,out), dimension(nmax),depend(nmax) :: ty
!           real*8,intent(out), dimension((nxest-kx-1)*(nyest-ky-1)),depend(kx,ky,nxest,nyest) :: c
!           real*8,intent(out) :: fp
!           !real*8,optional, dimension(nxest*nyest*(2+kx*nyest+2*ky*nxest)+2*(nxest+nyest + 6*(m+MAX(nxest,nyest))+MAX(nxest,nyest))),depend(nxest,nyest,kx,kv,m) :: wrk1
!           real*8,optional,dimension(10e6) :: wrk1
!           integer, optional,check(len(wrk1)>=lwrk1),depend(wrk1) :: lwrk1=len(wrk1)
!           !real*8,optional, dimension(nxest*nyest*(kx*nyest+ky*nxest)+nxest+nyest),depend(kx,ky,nxest,nyest) :: wrk2
!           real*8, optional,dimension(1e6) :: wrk2
!           integer, optional,check(len(wrk2)>=lwrk2),depend(wrk2) :: lwrk2=len(wrk2)
!           integer,optional, dimension(m+(nxest-2*kx-1)*(nyest-2*ky-1)):: iwrk
!           integer optional,check(len(iwrk)>=kwrk),depend(iwrk) :: kwrk=len(iwrk)
!           integer,intent(out) :: ier
!         end subroutine surfit


!         subroutine bispev(tx,nx,ty,ny,c,kx,ky,x,mx,y,my,z,wrk,lwrk,iwrk,kwrk,ier) ! in bispev.f
!           real*8,intent(in), dimension(nx) :: tx
!           integer optional,check(len(tx)>=nx),depend(tx) :: nx=len(tx)
!           real*8,intent(in), dimension(ny) :: ty
!           integer optional,check(len(ty)>=ny),depend(ty) :: ny=len(ty)
!           real*8,intent(in), dimension((nx-kx-1)*(ny-ky-1)),depend(nx,ny,kx,ky) :: c
!           integer,intent(in) :: kx
!           integer,intent(in) :: ky
!           real*8,intent(in), dimension(mx) :: x
!           integer optional,check(len(x)>=mx),depend(x) :: mx=len(x)
!           real*8,intent(in), dimension(my) :: y
!           integer optional,check(len(y)>=my),depend(y) :: my=len(y)
!           real*8,intent(out), dimension(mx*my),depend(mx,my) :: z
!           real*8, optional,dimension(mx*(kx+1)+my*(ky+1)),depend(mx,my,kx,ky) :: wrk
!           integer optional,check(len(wrk)>=lwrk),depend(wrk) :: lwrk=len(wrk)
!           integer optional,dimension(mx+my),depend(mx,my) :: iwrk
!           integer optional,check(len(iwrk)>=kwrk),depend(iwrk) :: kwrk=len(iwrk)
!           integer,intent(out) :: ier
!         end subroutine bispev

!         subroutine fit_foil(m,n,a,x1,x2,y1,y2,coefs) ! in fit_foil.f90
!           integer optional,check(shape(a,0)==m),depend(a) :: m=shape(a,0)
!           integer optional,intent(in),check(shape(a,1)==n),depend(a) :: n=shape(a,1)
!           double precision dimension(m,n),intent(in) :: a
!           double precision dimension(m),intent(in,copy),depend(m) :: x1
!           double precision dimension(m),intent(in,copy),depend(m) :: x2
!           double precision dimension(m),intent(in,copy),depend(m) :: y1
!           double precision dimension(m),intent(in,copy),depend(m) :: y2
!           double precision dimension(n,4),intent(out),depend(n) :: coefs
!         end subroutine fit_foil


!         subroutine fit_surf(nu,nv,nctlu,nctlv,a,x,ctl) ! in fit_surf.f90
!           integer intent(in) :: nu
!           integer intent(in) :: nv
!           integer intent(in) :: nctlu
!           integer intent(in) :: nctlv
!           double precision dimension(nu*nv,nctlu*nctlv),intent(in),depend(nu,nv,nctlu,nctlv) :: a
!           double precision dimension(nu,nv,3),intent(in),depend(nu,nv) :: x
!           double precision dimension(nctlu,nctlv,3),intent(out),depend(nctlu,nctlv) :: ctl
!         end subroutine fit_surf
